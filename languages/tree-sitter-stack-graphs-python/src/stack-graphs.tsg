;; -*- coding: utf-8 -*-
;; ------------------------------------------------------------------------------------------------
;; Copyright Â© 2023, stack-graphs authors.
;; Licensed under either of Apache License, Version 2.0, or MIT license, at your option.
;; Please see the LICENSE-APACHE or LICENSE-MIT files in this distribution for license details.
;; ------------------------------------------------------------------------------------------------

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Stack graphs definition for Python
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; Global Variables
;; ^^^^^^^^^^^^^^^^

global FILE_PATH
global ROOT_NODE
global JUMP_TO_SCOPE_NODE

;; Attribute Shorthands
;; ^^^^^^^^^^^^^^^^^^^^

attribute node_definition = node        => type = "pop_symbol", node_symbol = node, is_definition
attribute node_reference = node         => type = "push_symbol", node_symbol = node, is_reference
attribute pop_node = node               => type = "pop_symbol", node_symbol = node
attribute pop_scoped_node = node        => type = "pop_scoped_symbol", node_symbol = node
attribute pop_scoped_symbol = symbol    => type = "pop_scoped_symbol", symbol = symbol
attribute pop_symbol = symbol           => type = "pop_symbol", symbol = symbol
attribute push_node = node              => type = "push_symbol", node_symbol = node
attribute push_scoped_node = node       => type = "push_scoped_symbol", node_symbol = node
attribute push_scoped_symbol = symbol   => type = "push_scoped_symbol", symbol = symbol
attribute push_symbol = symbol          => type = "push_symbol", symbol = symbol
attribute scoped_node_definition = node => type = "pop_scoped_symbol", node_symbol = node, is_definition
attribute scoped_node_reference = node  => type = "push_scoped_symbol", node_symbol = node, is_reference
attribute symbol_definition = symbol    => type = "pop_symbol", symbol = symbol, is_definition
attribute symbol_reference = symbol     => type = "push_symbol", symbol = symbol, is_reference

attribute node_symbol = node            => symbol = (source-text node), source_node = node

;; Nodes
;; ^^^^^

(module) @node {
  node @node.after_scope
  node @node.before_scope
}

[
  ; _simple_statement
  (future_import_statement)
  (import_statement)
  (import_from_statement)
  (print_statement)
  (assert_statement)
  (expression_statement)
  (return_statement)
  (delete_statement)
  (raise_statement)
  (pass_statement)
  (break_statement)
  (continue_statement)
  (global_statement)
  (nonlocal_statement)
  (exec_statement)
  ; _compund_statement
  (if_statement)
  (for_statement)
  (while_statement)
  (try_statement)
  (with_statement)
  (function_definition)
  (class_definition)
  (decorated_definition)
  (match_statement)
  ; block
  (block)
  ; statement clauses
  (elif_clause)
  (else_clause)
  (case_clause)
  (except_clause)
  (finally_clause)
  (with_clause)
] @node {
  node @node.after_scope
  node @node.before_scope
}

(parameters) @node {
  node @node.after_scope
  node @node.before_scope
}

[
  (identifier)
  (import_prefix)
  (wildcard_import)
] @node {
  node @node.def
  node @node.def_dot
  node @node.ref
  node @node.ref_dot
}

[
  (identifier)
  (wildcard_import)
  (expression)
  (expression_list)
  (primary_expression)
  (pattern)
  (pattern_list)
  (case_pattern)
  (parameter)
  (pair)
  (list_splat)
  (parenthesized_list_splat)
  (dictionary_splat)
  (keyword_argument)
] @node {
  node @node.input
  node @node.new_bindings
  node @node.output
}

(comment) @node {
  node @node.after_scope
  node @node.before_scope
  node @node.def
  node @node.def_dot
  node @node.input
  node @node.new_bindings
  node @node.output
  node @node.ref
  node @node.ref_dot
}

;; Inherited Variables
;; ^^^^^^^^^^^^^^^^^^^

inherit .bottom
inherit .class_member_attr_scope
inherit .class_parent_scope
inherit .class_self_scope
inherit .class_super_scope
inherit .function_returns
inherit .global
inherit .global_dot
inherit .grandparent_module
inherit .local_scope
inherit .parent_module

; Modules and Imports
;---------------------

(module) @mod
{
  node mod_file_def
  node mod_file_ref

  var module_def = mod_file_def

  node parent_module_def_node
  var parent_module_def = parent_module_def_node

  var module_ref = mod_file_ref

  node parent_module_ref_node
  var parent_module_ref = parent_module_ref_node

  node grandparent_module_ref_node
  var grandparent_module_ref = grandparent_module_ref_node

  scan FILE_PATH {
    "([^/]+)/"
    {
      node def_dot
      attr (def_dot) pop_symbol = "."
      node next_def
      ;
      edge module_def -> def_dot
      edge def_dot -> next_def
      ;
      attr (module_def) pop_symbol = $1
      ;
      set parent_module_def = module_def
      set module_def = next_def

      node ref_dot
      attr (ref_dot) push_symbol = "."
      node next_ref
      ;
      edge next_ref -> ref_dot
      edge ref_dot -> module_ref
      ;
      attr (module_ref) push_symbol = $1
      ;
      set grandparent_module_ref = parent_module_ref
      set parent_module_ref = module_ref
      set module_ref = next_ref
    }

    "__init__\.py$"
    {
      attr (parent_module_def) is_definition, source_node = @mod, empty_source_span
    }

    "([^/]+)\.py$"
    {
      node def_dot
      attr (def_dot) pop_symbol = "."
      node next_def
      ;
      edge module_def -> def_dot
      edge def_dot -> next_def
      ;
      attr (module_def) pop_symbol = $1, is_definition, source_node = @mod, empty_source_span
      ;
      set module_def = next_def
    }
  }

  edge ROOT_NODE -> mod_file_def
  edge mod_file_ref -> ROOT_NODE
  edge module_def -> @mod.after_scope

  node global
  node global_dot

  edge @mod.before_scope -> global_dot
  edge global -> ROOT_NODE
  attr (global) push_symbol = "<builtins>"

  edge global_dot -> global
  attr (global_dot) push_symbol = "."

  let @mod.parent_module = parent_module_ref
  let @mod.grandparent_module = grandparent_module_ref
  let @mod.bottom = @mod.after_scope
  let @mod.global = global
  let @mod.global_dot = global_dot

  ;; add a dummy nodes for inherited variables
  node @mod.class_member_attr_scope
  node @mod.class_parent_scope
  node @mod.class_self_scope
  node @mod.class_super_scope
  node @mod.function_returns
  node @mod.local_scope
}

(import_statement
  name: (dotted_name
    . (identifier) @root_name)) @stmt
{
  edge @stmt.after_scope -> @root_name.def
  attr (@stmt.after_scope -> @root_name.def) precedence = 1
  edge @root_name.ref -> ROOT_NODE
}

(import_statement
  name: (aliased_import
    (dotted_name . (identifier) @root_name)))
{
  edge @root_name.ref -> ROOT_NODE
}

(import_from_statement
  name: (dotted_name
    . (identifier) @import_root_name)) @stmt
{
  edge @stmt.after_scope -> @import_root_name.def
  attr (@stmt.after_scope -> @import_root_name.def) precedence = 1
  edge @import_root_name.ref -> @import_root_name.ref_dot
  attr (@import_root_name.ref_dot) push_symbol = "."
}

(import_from_statement
  name: (aliased_import
    (dotted_name
      . (identifier) @import_root_name)))
{
  edge @import_root_name.ref -> @import_root_name.ref_dot
  attr (@import_root_name.ref_dot) push_symbol = "."
}

(import_from_statement
  module_name: [
    (dotted_name (identifier) @prefix_leaf_name .)
    (relative_import (dotted_name (identifier) @prefix_leaf_name .))
    (relative_import (import_prefix) @prefix_leaf_name .)
  ]
  name: [
    (dotted_name
      . (identifier) @import_root_name)
    (aliased_import
      (dotted_name
        . (identifier) @import_root_name))
  ])
{
  edge @import_root_name.ref_dot -> @prefix_leaf_name.ref
}

[
  (import_from_statement
    (aliased_import
      name: (dotted_name (identifier) @name .)
      alias: (identifier) @alias))
  (import_statement
    (aliased_import
      name: (dotted_name (identifier) @name .)
      alias: (identifier) @alias))
] @stmt
{
  edge @stmt.after_scope -> @alias.def
  edge @alias.def -> @name.ref
}

[
  (import_statement
    name: (dotted_name
      (identifier) @leaf_name .))
  (import_from_statement
    name: (dotted_name
      (identifier) @leaf_name .))
]
{
  edge @leaf_name.def -> @leaf_name.ref
}

(relative_import
  (import_prefix) @prefix
  (#eq? @prefix ".")) @import
{
  edge @prefix.ref -> @import.parent_module
}

(relative_import
  (import_prefix) @prefix
  (#eq? @prefix "..")) @import
{
  edge @prefix.ref -> @import.grandparent_module
}

(relative_import
  (import_prefix) @prefix
  (dotted_name
    . (identifier) @name))
{
  attr (@name.ref_dot) push_symbol = "."
  edge @name.ref -> @name.ref_dot
  edge @name.ref_dot -> @prefix.ref
}

[
  (import_from_statement
    module_name: (relative_import
      (dotted_name
        (identifier) @parent_name
        .
        (identifier) @child_name)))
  (import_from_statement
    module_name: (dotted_name
      (identifier) @parent_name
      .
      (identifier) @child_name))
]
{
  attr (@child_name.ref_dot) push_symbol = "."
  edge @child_name.ref -> @child_name.ref_dot
  edge @child_name.ref_dot -> @parent_name.ref
}

(import_from_statement
  module_name: (dotted_name
    . (identifier) @root_name))
{
  edge @root_name.ref -> ROOT_NODE
}

(import_from_statement
  module_name: (dotted_name
    (identifier) @leaf_name .)
  (wildcard_import) @star) @stmt
{
  edge @stmt.after_scope -> @star.ref_dot
  attr (@stmt.after_scope -> @star.ref_dot) precedence = 1
  edge @star.ref_dot -> @leaf_name.ref
  attr (@star.ref_dot) push_symbol = "."
}

[
  (import_statement
    name: (dotted_name
      (identifier) @parent_name
      .
      (identifier) @child_name))
  (import_from_statement
    name: (dotted_name
      (identifier) @parent_name
      .
      (identifier) @child_name))
  (import_from_statement
    name: (aliased_import
      name: (dotted_name
        (identifier) @parent_name
        .
        (identifier) @child_name)))
]
{
  edge @child_name.ref -> @child_name.ref_dot
  edge @child_name.ref_dot -> @parent_name.ref
  edge @parent_name.def -> @parent_name.def_dot
  edge @parent_name.def_dot -> @child_name.def
  attr (@parent_name.def_dot) pop_symbol = "."
  attr (@child_name.ref_dot) push_symbol = "."
}

;--------
; Scopes
;--------

[
  (module (_) @last_stmt .)
  (block (_) @last_stmt .)
] @block
{
  edge @block.after_scope -> @last_stmt.after_scope
}

[
  (module (_) @stmt1 . (_) @stmt2)
  (block (_) @stmt1 . (_) @stmt2)
]
{
  edge @stmt2.before_scope -> @stmt1.after_scope
}

[
  (module (_) @stmt)
  (block (_) @stmt)
]
{
  edge @stmt.after_scope -> @stmt.before_scope
  let @stmt.local_scope = @stmt.before_scope
}

[
  (block . (_) @stmt)
  (module . (_) @stmt)
] @block
{
  edge @stmt.before_scope -> @block.before_scope
}

(function_definition (block) @block)
{
  edge @block.before_scope -> @block.local_scope
}

[
  (while_statement (block) @block)
  (if_statement (block) @block)
  (with_statement (block) @block)
  (try_statement (block) @block)
  (for_statement (block) @block)
  (_ [
    (else_clause (block) @block)
    (elif_clause (block) @block)
    (except_clause (block) @block)
    (finally_clause (block) @block)
  ])
] @stmt
{
  edge @block.before_scope -> @block.local_scope
  edge @stmt.after_scope -> @block.after_scope
}

(match_statement (case_clause) @block) @stmt
{
  let @block.local_scope = @block.before_scope
  edge @block.before_scope -> @stmt.before_scope
  edge @stmt.after_scope -> @block.after_scope
}

[
  (for_statement)
  (while_statement)
] @stmt
{
  edge @stmt.before_scope -> @stmt.after_scope
}

;-------------
; Definitions
;-------------

(identifier) @name {
  attr (@name.def) node_definition = @name
}

[
  (assignment
    left: (_) @pattern
    right: (_) @value)
  (with_item
    value:
      (as_pattern
        (_) @value
        alias: (as_pattern_target (_) @pattern)))
]
{
  edge @pattern.input -> @value.output
}

(function_definition
  name: (identifier) @name
  parameters: (parameters) @params
  body: (block) @body) @func
{
  node call
  node drop_scope
  node return_value

  attr (@name.def) definiens_node = @func
  edge @func.after_scope -> @name.def
  edge @name.def -> call
  edge call -> return_value
  edge @body.before_scope -> @params.after_scope
  edge @body.before_scope -> drop_scope
  edge drop_scope -> @func.bottom
  attr (drop_scope) type = "drop_scopes"
  attr (call) pop_scoped_symbol = "()"
  edge @params.before_scope -> JUMP_TO_SCOPE_NODE
  attr (return_value) is_exported
  let @func.function_returns = return_value

  ; Prevent functions defined inside of method bodies from being treated like methods
  let @body.class_self_scope = #null
  let @body.class_member_attr_scope = #null
}

;;
;; BEGIN BIG GNARLY DISJUNCTION
;;
;; The following pair of rules is intended to capture the following behavior:
;;
;; If a function definition is used to define a method, by being inside a class
;; definition, then we make its syntax type `method`. Otherwise, we make it's
;; syntax type `function`. Unfortunately, because of the limitations on negation
;; and binding in tree sitter queries, we cannot negate `class_definition` or
;; similar things directly. Instead, we have to manually push the negation down
;; to form the finite disjunction it corresponds to.
;;

[
  (class_definition (block (decorated_definition (function_definition name: (_)@name))))
  (class_definition (block (function_definition name: (_)@name)))
]
{
  attr (@name.def) syntax_type = "method"
}

[
  (module (decorated_definition (function_definition name: (_)@name)))
  (module (function_definition name: (_)@name))

  (if_statement (block (decorated_definition (function_definition name: (_)@name))))
  (if_statement (block (function_definition name: (_)@name)))

  (elif_clause (block (decorated_definition (function_definition name: (_)@name))))
  (elif_clause (block (function_definition name: (_)@name)))

  (else_clause (block (decorated_definition (function_definition name: (_)@name))))
  (else_clause (block (function_definition name: (_)@name)))

  (case_clause (block (decorated_definition (function_definition name: (_)@name))))
  (case_clause (block (function_definition name: (_)@name)))

  (for_statement (block (decorated_definition (function_definition name: (_)@name))))
  (for_statement (block (function_definition name: (_)@name)))

  (while_statement (block (decorated_definition (function_definition name: (_)@name))))
  (while_statement (block (function_definition name: (_)@name)))

  (try_statement (block (decorated_definition (function_definition name: (_)@name))))
  (try_statement (block (function_definition name: (_)@name)))

  (except_clause (block (decorated_definition (function_definition name: (_)@name))))
  (except_clause (block (function_definition name: (_)@name)))

  (finally_clause (block (decorated_definition (function_definition name: (_)@name))))
  (finally_clause (block (function_definition name: (_)@name)))

  (with_statement (block (decorated_definition (function_definition name: (_)@name))))
  (with_statement (block (function_definition name: (_)@name)))

  (function_definition (block (decorated_definition (function_definition name: (_)@name))))
  (function_definition (block (function_definition name: (_)@name)))
]
{
  attr (@name.def) syntax_type = "function"
}

;;
;; END BIG GNARLY DISJUNCTION
;;

(function_definition
  parameters: (parameters
    . (identifier) @param)
  body: (block) @body)
{
  edge @param.def -> @param.class_self_scope
  edge @param.class_member_attr_scope -> @param.output
  edge @param.output -> @body.after_scope
  attr (@param.output) push_node = @param
}

(parameter/identifier) @param @name
{
  attr (@param.param_name) push_node = @param
  edge @name.def -> @param.param_name
  edge @name.def -> @param.param_index
  edge @param.input -> @name.def
}

[
  (parameter/default_parameter
    name: (identifier) @name
    value: (_) @value) @param
  (parameter/typed_default_parameter
    name: (_) @name
    value: (_) @value) @param
]
{
  attr (@param.param_name) push_node = @name
  edge @name.def -> @param.param_name
  edge @name.def -> @param.param_index
  edge @param.input -> @name.def
  edge @name.def -> @value.output
}

[
  (parameter/typed_parameter
    . (_) @name) @param
  (parameter/list_splat_pattern
    (_) @name) @param
  (parameter/dictionary_splat_pattern
    (_) @name) @param
]
{
  attr (@param.param_name) push_node = @name
  edge @name.def -> @param.param_name
  edge @name.def -> @param.param_index
  edge @param.input -> @name.def
}

[
  (pattern_list (_) @pattern)
  (tuple_pattern (_) @pattern)
] @list
{
  node pattern_index

  let statement_scope = @list.local_scope
  node @pattern.local_scope
  edge statement_scope -> @pattern.local_scope
  attr (statement_scope -> @pattern.local_scope) precedence = (plus 1 (named-child-index @pattern))

  edge pattern_index -> @list.input
  edge @pattern.input -> pattern_index
  attr (pattern_index) push_symbol = (named-child-index @pattern)
}

(parameters
  (_) @param) @params
{
  node @param.param_index
  node @param.param_name

  attr (@param.param_index) push_symbol = (named-child-index @param)
  edge @param.param_index -> @params.before_scope
  edge @params.after_scope -> @param.input
  edge @param.param_name -> @params.before_scope
}

(return_statement (_) @expr) @stmt
{
  edge @stmt.function_returns -> @expr.output
}

(class_definition) @class {
  node @class.call_drop
  node @class.member_attrs
  node @class.members
  node @class.super_scope
}

(class_definition
  name: (identifier) @name) @class
{
  node call
  node self_dot
  node self_scope
  node members_dot

  attr (@name.def) definiens_node = @class
  attr (@name.def) syntax_type = "class"
  edge @class.after_scope -> @name.def
  edge @name.def -> call
  edge @name.def -> members_dot
  edge members_dot -> @class.members
  edge call -> @class.call_drop
  edge @class.call_drop -> self_scope
  edge self_scope -> @class.super_scope
  edge self_scope -> self_dot
  edge self_dot -> @class.members
  edge @class.members -> @class.member_attrs
  attr (call) pop_scoped_symbol = "()"
  attr (@class.call_drop) type = "drop_scopes"
  attr (members_dot) pop_symbol = "."
  attr (self_dot) pop_symbol = "."
  attr (@class.member_attrs) push_symbol = "."
  attr (self_scope) is_exported
}

(class_definition
  body: (_) @body) @class
{
  let @body.class_member_attr_scope = @class.member_attrs
  node @body.class_parent_scope
  edge @body.class_parent_scope -> @class.class_parent_scope
  edge @body.class_parent_scope -> @class.local_scope
  let @body.class_self_scope = @class.call_drop
  let @body.class_super_scope = @class.super_scope
}

(class_definition
  body: (block
    (_) @last_stmt .)) @class
{
  edge @class.members -> @last_stmt.after_scope
}

(class_definition
  superclasses: (argument_list
    (_) @superclass)) @class
{
  edge @class.super_scope -> @superclass.output
}

(decorated_definition
  definition: (_) @def) @stmt
{
  edge @def.before_scope -> @stmt.before_scope
  edge @stmt.after_scope -> @def.after_scope
}

(case_clause
  pattern: (_) @pattern
  consequence: (_) @consequence) @clause
{
  edge @consequence.before_scope -> @pattern.new_bindings
  edge @consequence.before_scope -> @clause.before_scope
  edge @clause.after_scope -> @consequence.after_scope
}

;-------------
; Expressions
;-------------

(identifier) @name {
  attr (@name.ref) node_reference = @name
}

(call
  function: (_) @fn
  arguments: (argument_list) @args) @call
{
  node output_args

  edge @call.output -> output_args
  edge output_args -> @fn.output
  attr (output_args) push_scoped_symbol = "()", scope = @args.args
}

(call
  function: (attribute
    object: (_) @receiver)
  arguments: (argument_list
    (expression) @arg) @args)
{
  node receiver_arg_index
  attr (receiver_arg_index) pop_symbol = "0"
  edge @args.args -> receiver_arg_index
  edge receiver_arg_index -> @receiver.output

  ;; FIXME the arguments will also exist with their unshifted indices because of the general
  ;;       rule below!
  node arg_index
  attr (arg_index) pop_symbol = (plus 1 (named-child-index @arg))
  edge arg_index -> @arg.output
}

(call
  arguments: (argument_list
    (keyword_argument
      name: (identifier) @name
      value: (_) @val)) @args)
{
  node arg_name
  edge @args.args -> arg_name
  attr (arg_name) pop_node = @name
  edge arg_name -> @val.output
}

(argument_list) @args {
  node @args.args
  attr (@args.args) is_exported
}

(argument_list
  (expression) @arg) @args
{
  node arg_index
  edge @args.args -> arg_index
  attr (arg_index) pop_symbol = (named-child-index @arg)
  edge arg_index -> @arg.output
}

(
  (call
    function: (identifier) @_fn_name) @call
  (#eq? @_fn_name "super")
)
{
  edge @call.output -> @call.class_super_scope
}

[
  (tuple (_) @element)
  (expression_list (_) @element)
] @tuple
{
  node el_index

  edge @tuple.output -> el_index
  attr (el_index) pop_symbol = (named-child-index @element)
  edge el_index -> @element.output

  edge @tuple.new_bindings -> @element.new_bindings
}

(attribute
  object: (_) @object
  attribute: (identifier) @name) @expr
{
  node input_dot
  node output_dot

  edge @expr.output -> @name.output
  edge @name.output -> output_dot
  edge output_dot -> @object.output
  edge @object.input -> input_dot
  edge input_dot -> @name.input
  edge @name.input -> @expr.input
  attr (output_dot) push_symbol = "."
  attr (input_dot) pop_symbol = "."
  attr (@name.input) pop_node = @name
  attr (@name.output) push_node = @name
}

(pattern/attribute
  attribute: (identifier) @name)
{
  attr (@name.input) is_definition
}

(primary_expression/attribute
  attribute: (identifier) @name)
{
  attr (@name.output) is_reference
}

(primary_expression/identifier) @id
{
  edge @id.output -> @id.local_scope
  edge @id.output -> @id.class_parent_scope
  edge @id.local_scope -> @id.input
  attr (@id.input) pop_node = @id
  attr (@id.output) node_reference = @id

  edge @id.new_bindings -> @id.def
}

(pattern/identifier) @id
{
  edge @id.output -> @id.local_scope
  edge @id.output -> @id.class_parent_scope
  edge @id.local_scope -> @id.input
  attr (@id.local_scope -> @id.input) precedence = 1
  attr (@id.input) node_definition = @id
  attr (@id.output) push_node = @id

  edge @id.new_bindings -> @id.def
}

(as_pattern
  (expression) @value
  alias: (as_pattern_target (primary_expression/identifier) @id)) @as_pattern
{
  attr (@id.local_scope -> @id.input) precedence = 1
  attr (@id.input) is_definition

  edge @as_pattern.new_bindings -> @value.new_bindings
  edge @as_pattern.new_bindings -> @id.new_bindings
}

(list) @list
{
  node called

  edge @list.output -> called
  edge called -> @list.global_dot
  attr (called) push_symbol = "list"
}

(list (_) @el) @list
{
  edge @list.new_bindings -> @el.new_bindings
}

(dictionary (pair) @pair) @dict
{
  edge @dict.new_bindings -> @pair.new_bindings
}

(pair
  value: (_) @value) @pair
{
  edge @pair.new_bindings -> @value.new_bindings
}

(set (_) @el) @set
{
  edge @set.new_bindings -> @el.new_bindings
}

(list_splat (_) @splatted) @splat
{
  edge @splat.new_bindings -> @splatted.new_bindings
}

(binary_operator
  (_) @left
  (_) @right) @binop
{
  edge @binop.new_bindings -> @left.new_bindings
  edge @binop.new_bindings -> @right.new_bindings
}

(case_pattern (_) @expr) @pat
{
  edge @pat.new_bindings -> @expr.new_bindings
}
